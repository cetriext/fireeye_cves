{
  "information": {
    "description": [
      {
        "id": "CVE-2019-0604",
        "parameters": {
          "published": "2019-03-05T23:29Z",
          "modified": "2019-12-13T15:17Z",
          "summary": "A remote code execution vulnerability exists in Microsoft SharePoint when the software fails to check the source markup of an application package, aka 'Microsoft SharePoint Remote Code Execution Vulnerability'. This CVE ID is unique from CVE-2019-0594."
        }
      }
    ],
    "references": [
      {
        "vendor": "BID",
        "url": "http://www.securityfocus.com/bid/106914"
      },
      {
        "vendor": "CONFIRM",
        "url": "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0604"
      }
    ]
  },
  "classification": {
    "targets": [
      {
        "id": 1,
        "parameters": [
          {
            "title": "Microsoft SharePoint Enterprise Server 2016",
            "cpe2.2": "cpe:/a:microsoft:sharepoint_enterprise_server:2016",
            "cpe2.3": "cpe:2.3:a:microsoft:sharepoint_enterprise_server:2016:*:*:*:*:*:*:*",
            "version_affected": {
              "from": "",
              "to": ""
            }
          },
          {
            "title": "Microsoft SharePoint Foundation 2013 Service Pack 1",
            "cpe2.2": "cpe:/a:microsoft:sharepoint_foundation:2013:sp1",
            "cpe2.3": "cpe:2.3:a:microsoft:sharepoint_foundation:2013:sp1:*:*:*:*:*:*",
            "version_affected": {
              "from": "",
              "to": ""
            }
          },
          {
            "title": "Microsoft Sharepoint Server 2010 Service Pack 2",
            "cpe2.2": "cpe:/a:microsoft:sharepoint_server:2010:sp2",
            "cpe2.3": "cpe:2.3:a:microsoft:sharepoint_server:2010:sp2:*:*:*:*:*:*",
            "version_affected": {
              "from": "",
              "to": ""
            }
          },
          {
            "title": "Microsoft SharePoint Server 2019",
            "cpe2.2": "cpe:/a:microsoft:sharepoint_server:2019",
            "cpe2.3": "cpe:2.3:a:microsoft:sharepoint_server:2019:*:*:*:*:*:*:*",
            "version_affected": {
              "from": "",
              "to": ""
            }
          }
        ]
      }
    ],
    "packages": [
      {
        "microsoft": [
          {
            "product": "sharepoint enterprise server",
            "version": {
              "affected": "2016",
              "condition": "equal"
            }
          },
          {
            "product": "sharepoint foundation",
            "version": {
              "affected": "2013",
              "condition": "equal"
            }
          },
          {
            "product": "sharepoint server",
            "version": {
              "affected": "2010",
              "condition": "equal"
            }
          },
          {
            "product": "sharepoint server",
            "version": {
              "affected": "2019",
              "condition": "equal"
            }
          }
        ]
      }
    ],
    "weaknesses": [
      {
        "id": "CWE-20",
        "parameters": {
          "class": "weakness",
          "title": "Improper Input Validation",
          "relationship": "CWE-770,CWE-119,CWE-74,CWE-41,CWE-22,CWE-345,CWE-707",
          "url": "https://cwe.mitre.org/data/definitions/20.html",
          "attack_patterns": [
            {
              "id": "CAPEC-9",
              "parameters": {
                "title": "Buffer Overflow in Local Command-Line Utilities",
                "attack_methods": "",
                "mitigations": "Do not unnecessarily expose services.|Apply the latest patches to your user exposed services. This may not be a complete solution, especially against a zero day attack.|Operational: Use OS-level preventative functionality. Not a complete solution.|Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.|Use an abstraction library to abstract away risky APIs. Not a complete solution.|Use a language or compiler that performs automatic bounds checking.|Carefully review the service's implementation before making it available to user. For instance you can use manual or automated code review to uncover vulnerabilities such as buffer overflow.",
                "url": "https://capec.mitre.org/data/definitions/9.html"
              }
            },
            {
              "id": "CAPEC-88",
              "parameters": {
                "title": "OS Command Injection",
                "attack_methods": "",
                "mitigations": "All application processes should be run with the minimal privileges required. Also, processes must shed privileges as soon as they no longer require them.|Filter all incoming data to escape or remove characters or strings that can be potentially misinterpreted as operating system or shell commands|Use language APIs rather than relying on passing data to the operating system shell or command line. Doing so ensures that the available protection mechanisms in the language are intact and applicable.",
                "url": "https://capec.mitre.org/data/definitions/88.html"
              }
            },
            {
              "id": "CAPEC-85",
              "parameters": {
                "title": "AJAX Fingerprinting",
                "attack_methods": "",
                "mitigations": "Implementation: Perform input validation for all remote content.|Design: Use browser technologies that do not allow client side scripting.",
                "url": "https://capec.mitre.org/data/definitions/85.html"
              }
            },
            {
              "id": "CAPEC-83",
              "parameters": {
                "title": "XPath Injection",
                "attack_methods": "",
                "mitigations": "Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the database or application.|Use of parameterized XPath queries - Parameterization causes the input to be restricted to certain domains, such as strings or integers, and any input outside such domains is considered invalid and the query fails.|Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as content that can be interpreted in the context of an XPath expression. Characters such as a single-quote(') or operators such as or (|), and (&) and such should be filtered if the application does not expect them in the context in which they appear. If such content cannot be filtered, it must at least be properly escaped to avoid them being interpreted as part of XPath expressions.",
                "url": "https://capec.mitre.org/data/definitions/83.html"
              }
            },
            {
              "id": "CAPEC-81",
              "parameters": {
                "title": "Web Logs Tampering",
                "attack_methods": "",
                "mitigations": "Design: Validate all log data before it is output|Design: Use input validation before writing to web log",
                "url": "https://capec.mitre.org/data/definitions/81.html"
              }
            },
            {
              "id": "CAPEC-80",
              "parameters": {
                "title": "Using UTF-8 Encoding to Bypass Validation Logic",
                "attack_methods": "",
                "mitigations": "Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system. Test your decoding process against malicious input.|Look for overlong UTF-8 sequences starting with malicious pattern. You can also use a UTF-8 decoder stress test to test your UTF-8 parser (See Markus Kuhn's UTF-8 and Unicode FAQ in reference section)|For security reasons, a UTF-8 decoder must not accept UTF-8 sequences that are longer than necessary to encode a character. If you use a parser to decode the UTF-8 encoding, make sure that parser filter the invalid UTF-8 characters (invalid forms or overlong forms).||The Unicode Consortium recognized multiple representations to be a problem and has revised the Unicode Standard to make multiple representations of the same code point with UTF-8 illegal. The UTF-8 Corrigendum lists the newly restricted UTF-8 range (See references). Many current applications may not have been revised to follow this rule. Verify that your application conform to the latest UTF-8 encoding specification. Pay extra attention to the filtering of illegal characters.",
                "url": "https://capec.mitre.org/data/definitions/80.html"
              }
            },
            {
              "id": "CAPEC-8",
              "parameters": {
                "title": "Buffer Overflow in an API Call",
                "attack_methods": "",
                "mitigations": "Use OS-level preventative functionality. Not a complete solution.|Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.|If you have to use dangerous functions, make sure that you do boundary checking.|Use secure functions not vulnerable to buffer overflow.|Use a language or compiler that performs automatic bounds checking.",
                "url": "https://capec.mitre.org/data/definitions/8.html"
              }
            },
            {
              "id": "CAPEC-79",
              "parameters": {
                "title": "Using Slashes in Alternate Encoding",
                "attack_methods": "",
                "mitigations": "Assume all input is malicious. Create an allowlist that defines all valid input to the application based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system.|In the case of path traversals, use the principle of least privilege when determining access rights to file systems. Do not allow users to access directories/files that they should not access.|Test your path decoding process against malicious input.|Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. (See related guideline section)|There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx)|When client input is required from web-based forms, avoid using the \"GET\" method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the \"POST method whenever possible.|Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process. Refer to the RFCs to safely decode URL.",
                "url": "https://capec.mitre.org/data/definitions/79.html"
              }
            },
            {
              "id": "CAPEC-78",
              "parameters": {
                "title": "Using Escaped Slashes in Alternate Encoding",
                "attack_methods": "",
                "mitigations": "Avoid making decisions based on names of resources (e.g. files) if those resources can have alternate names.|Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.|In the case of path traversals, use the principle of least privilege when determining access rights to file systems. Do not allow users to access directories/files that they should not access.|Regular expressions can be used to filter out backslash. Make sure you decode before filtering and validating the untrusted input data.|Be aware of the threat of alternative method of data encoding.|Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system.|Verify that the user-supplied data does not use backslash character to escape malicious characters.",
                "url": "https://capec.mitre.org/data/definitions/78.html"
              }
            },
            {
              "id": "CAPEC-73",
              "parameters": {
                "title": "User-Controlled Filename",
                "attack_methods": "",
                "mitigations": "Implementation: Scan dynamically generated content against validation specification|Implementation: Disable scripting languages such as JavaScript in browser|Implementation: Perform output validation for all remote content.|Implementation: Perform input validation for all remote content.|Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.|Design: Use browser technologies that do not allow client side scripting.",
                "url": "https://capec.mitre.org/data/definitions/73.html"
              }
            },
            {
              "id": "CAPEC-72",
              "parameters": {
                "title": "URL Encoding",
                "attack_methods": "",
                "mitigations": "When client input is required from web-based forms, avoid using the \"GET\" method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the \"POST method whenever possible.|Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding. (See related guideline section)|Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system. Test your decoding process against malicious input.|Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.|There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).|Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive.|Refer to the RFCs to safely decode URL.",
                "url": "https://capec.mitre.org/data/definitions/72.html"
              }
            },
            {
              "id": "CAPEC-71",
              "parameters": {
                "title": "Using Unicode Encoding to Bypass Validation Logic",
                "attack_methods": "",
                "mitigations": "Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system.|Ensure that filtering or input validation is applied to canonical data.|Ensure that the system is Unicode aware and can properly process Unicode data. Do not make an assumption that data will be in ASCII.",
                "url": "https://capec.mitre.org/data/definitions/71.html"
              }
            },
            {
              "id": "CAPEC-7",
              "parameters": {
                "title": "Blind SQL Injection",
                "attack_methods": "",
                "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as SQL content. Keywords such as UNION, SELECT or INSERT must be filtered in addition to characters such as a single-quote(') or SQL-comments (--) based on the context in which they appear.|Security by Obscurity is not a solution to preventing SQL Injection. Rather than suppress error messages and exceptions, the application must handle them gracefully, returning either a custom error page or redirecting the user to a default page, without revealing any information about the database or the application internals.",
                "url": "https://capec.mitre.org/data/definitions/7.html"
              }
            },
            {
              "id": "CAPEC-67",
              "parameters": {
                "title": "String Format Overflow in syslog()",
                "attack_methods": "",
                "mitigations": "",
                "url": "https://capec.mitre.org/data/definitions/67.html"
              }
            },
            {
              "id": "CAPEC-64",
              "parameters": {
                "title": "Using Slashes and URL Encoding Combined to Bypass Validation Logic",
                "attack_methods": "",
                "mitigations": "There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).|Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive.|Refer to the RFCs to safely decode URL.|Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.|When client input is required from web-based forms, avoid using the \"GET\" method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the \"POST method whenever possible.|Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding.|Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system. Test your decoding process against malicious input.",
                "url": "https://capec.mitre.org/data/definitions/64.html"
              }
            },
            {
              "id": "CAPEC-63",
              "parameters": {
                "title": "Cross-Site Scripting (XSS)",
                "attack_methods": "",
                "mitigations": "Implementation: Patching software. There are many attack vectors for XSS on the client side and the server side. Many vulnerabilities are fixed in service packs for browser, web servers, and plug in technologies, staying current on patch release that deal with XSS countermeasures mitigates this.|Implementation: Session tokens for specific host|Implementation: Perform output validation for all remote content.|Implementation: Perform input validation for all remote content.|Implementation: Ensure all content that is delivered to client is sanitized against an acceptable content specification.|Design: Server side developers should not proxy content via XHR or other means, if a http proxy for remote content is setup on the server side, the client's browser has no way of discerning where the data is originating from.|Design: Utilize strict type, character, and encoding enforcement|Design: Use browser technologies that do not allow client side scripting.",
                "url": "https://capec.mitre.org/data/definitions/63.html"
              }
            },
            {
              "id": "CAPEC-588",
              "parameters": {
                "title": "DOM-Based XSS",
                "attack_methods": "",
                "mitigations": "Ensure that all user-supplied input is validated before use.|Utilize proper character encoding for all output produced within client-site scripts manipulating the DOM.|Use browser technologies that do not allow client-side scripting.",
                "url": "https://capec.mitre.org/data/definitions/588.html"
              }
            },
            {
              "id": "CAPEC-53",
              "parameters": {
                "title": "Postfix, Null Terminate, and Backslash",
                "attack_methods": "",
                "mitigations": "Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system.|Properly handle Null characters. Make sure canonicalization is properly applied. Do not pass Null characters to the underlying APIs.",
                "url": "https://capec.mitre.org/data/definitions/53.html"
              }
            },
            {
              "id": "CAPEC-52",
              "parameters": {
                "title": "Embedding NULL Bytes",
                "attack_methods": "",
                "mitigations": "Properly handle the NULL characters supplied as part of user input prior to doing anything with the data.",
                "url": "https://capec.mitre.org/data/definitions/52.html"
              }
            },
            {
              "id": "CAPEC-473",
              "parameters": {
                "title": "Signature Spoof",
                "attack_methods": "",
                "mitigations": "",
                "url": "https://capec.mitre.org/data/definitions/473.html"
              }
            },
            {
              "id": "CAPEC-47",
              "parameters": {
                "title": "Buffer Overflow via Parameter Expansion",
                "attack_methods": "",
                "mitigations": "Ensure that when parameter expansion happens in the code that the assumptions used to determine the resulting size of the parameter are accurate and that the new size of the parameter is visible to the whole system",
                "url": "https://capec.mitre.org/data/definitions/47.html"
              }
            },
            {
              "id": "CAPEC-46",
              "parameters": {
                "title": "Overflow Variables and Tags",
                "attack_methods": "",
                "mitigations": "Do not trust input data from user. Validate all user input.|Use OS-level preventative functionality. Not a complete solution.|Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.|Use an abstraction library to abstract away risky APIs. Not a complete solution.|Use a language or compiler that performs automatic bounds checking.",
                "url": "https://capec.mitre.org/data/definitions/46.html"
              }
            },
            {
              "id": "CAPEC-45",
              "parameters": {
                "title": "Buffer Overflow via Symbolic Links",
                "attack_methods": "",
                "mitigations": "Use OS-level preventative functionality. Not a complete solution.|Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.|Use an abstraction library to abstract away risky APIs. Not a complete solution.|Use a language or compiler that performs automatic bounds checking.|Always check the size of the input data before copying to a buffer.|Pay attention to the resource pointed to by your symlink links (See attack pattern named \"Forced Symlink race\"), they can be replaced by malicious resources.|Because Symlink can be modified by an attacker, make sure that the ones you read are located in protected directories.|Pay attention to the fact that the resource you read from can be a replaced by a Symbolic link. You can do a Symlink check before reading the file and decide that this is not a legitimate way of accessing the resource.",
                "url": "https://capec.mitre.org/data/definitions/45.html"
              }
            },
            {
              "id": "CAPEC-43",
              "parameters": {
                "title": "Exploiting Multiple Input Interpretation Layers",
                "attack_methods": "",
                "mitigations": "Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist would not be permitted to enter into the system.|Make sure to perform input validation on canonicalized data (i.e. data that is data in its most standard form). This will help avoid tricky encodings getting past the filters.|An iterative approach to input validation may be required to ensure that no dangerous characters are present. It may be necessary to implement redundant checking across different input validation layers. Ensure that invalid data is rejected as soon as possible and do not continue to work with it.",
                "url": "https://capec.mitre.org/data/definitions/43.html"
              }
            },
            {
              "id": "CAPEC-42",
              "parameters": {
                "title": "MIME Conversion",
                "attack_methods": "",
                "mitigations": "Use mail.local|Use the sendmail restricted shell program (smrsh)||Stay up to date with third party vendor patches",
                "url": "https://capec.mitre.org/data/definitions/42.html"
              }
            },
            {
              "id": "CAPEC-31",
              "parameters": {
                "title": "Accessing/Intercepting/Modifying HTTP Cookies",
                "attack_methods": "",
                "mitigations": "Implementation: Ensure the web server implements all relevant security patches, many exploitable buffer overflows are fixed in patches issued for the software.|Implementation: Use SSL/TLS to protect cookie in transit|Design: Generate and validate MAC for cookies|Design: Use input validation for cookies",
                "url": "https://capec.mitre.org/data/definitions/31.html"
              }
            },
            {
              "id": "CAPEC-3",
              "parameters": {
                "title": "Using Leading 'Ghost' Character Sequences to Bypass Input Filters",
                "attack_methods": "",
                "mitigations": "Take an iterative approach to input validation (defense in depth).|Canonicalize all data prior to validation.|Use an allowlist rather than a denylist input validation.",
                "url": "https://capec.mitre.org/data/definitions/3.html"
              }
            },
            {
              "id": "CAPEC-28",
              "parameters": {
                "title": "Fuzzing",
                "attack_methods": "",
                "mitigations": "Use fuzz testing during the software QA process to uncover any surprises, uncover any assumptions or unexpected behavior.|Test to ensure that the software behaves as per specification and that there are no unintended side effects. Ensure that no assumptions about the validity of data are made.",
                "url": "https://capec.mitre.org/data/definitions/28.html"
              }
            },
            {
              "id": "CAPEC-267",
              "parameters": {
                "title": "Leverage Alternate Encoding",
                "attack_methods": "",
                "mitigations": "Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system. Test your decoding process against malicious input.|Assume all input might use an improper representation. Use canonicalized data inside the application; all data must be converted into the representation used inside the application (UTF-8, UTF-16, etc.)",
                "url": "https://capec.mitre.org/data/definitions/267.html"
              }
            },
            {
              "id": "CAPEC-261",
              "parameters": {
                "title": "Fuzzing for garnering other adjacent user/sensitive data",
                "attack_methods": "",
                "mitigations": "",
                "url": "https://capec.mitre.org/data/definitions/261.html"
              }
            },
            {
              "id": "CAPEC-250",
              "parameters": {
                "title": "XML Injection",
                "attack_methods": "",
                "mitigations": "",
                "url": "https://capec.mitre.org/data/definitions/250.html"
              }
            },
            {
              "id": "CAPEC-24",
              "parameters": {
                "title": "Filter Failure through Buffer Overflow",
                "attack_methods": "",
                "mitigations": "Design: Use an abstraction library to abstract away risky APIs. Not a complete solution.|Operational: Use OS-level preventative functionality. Not a complete solution.|Pre-design through Build: Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.|Pre-design: Use a language or compiler that performs automatic bounds checking.|Make sure that ANY failure occurring in the filtering or input validation routine is properly handled and that offending input is NOT allowed to go through. Basically make sure that the vault is closed when failure occurs.",
                "url": "https://capec.mitre.org/data/definitions/24.html"
              }
            },
            {
              "id": "CAPEC-231",
              "parameters": {
                "title": "Oversized Serialized Data Payloads",
                "attack_methods": "",
                "mitigations": "Validate data against a valid schema or DTD prior to parsing.|Pick a robust implementation of the serialized data parser.|Perform validation on canonical data.|Carefully validate and sanitize all user-controllable serialized data prior to passing it to the parser routine. Ensure that the resultant data is safe to pass to the parser.",
                "url": "https://capec.mitre.org/data/definitions/231.html"
              }
            },
            {
              "id": "CAPEC-230",
              "parameters": {
                "title": "XML Nested Payloads",
                "attack_methods": "",
                "mitigations": "Validate XML against a valid schema or DTD prior to parsing.|Pick a robust implementation of an XML parser.|Perform validation on canonical data.|Carefully validate and sanitize all user-controllable data prior to passing it to the XML parser routine. Ensure that the resultant data is safe to pass to the XML parser.",
                "url": "https://capec.mitre.org/data/definitions/230.html"
              }
            },
            {
              "id": "CAPEC-23",
              "parameters": {
                "title": "File Content Injection",
                "attack_methods": "",
                "mitigations": "Implementation: Host integrity monitoring for critical files, directories, and processes. The goal of host integrity monitoring is to be aware when a security issue has occurred so that incident response and other forensic activities can begin.|Implementation: Virus scanning on host|Design: Proxy communication to host, so that communications are terminated at the proxy, sanitizing the requests before forwarding to server host.|Design: Execute programs with constrained privileges, so parent process does not open up further vulnerabilities. Ensure that all directories, temporary directories and files, and memory are executing with limited privileges to protect against remote execution.|Design: Validate all input for content including files. Ensure that if files and remote content must be accepted that once accepted, they are placed in a sandbox type location so that lower assurance clients cannot write up to higher assurance processes (like Web server processes for example)|Design: Enforce principle of least privilege",
                "url": "https://capec.mitre.org/data/definitions/23.html"
              }
            },
            {
              "id": "CAPEC-22",
              "parameters": {
                "title": "Exploiting Trust in Client",
                "attack_methods": "",
                "mitigations": "Implementation: Perform input validation for all remote content.|Design: Utilize two factor authentication to increase authentication assurance.|Design: Utilize digital signatures to increase authentication assurance.|Design: Do not rely on client validation or encoding for security purposes.|Design: Ensure that client process and/or message is authenticated so that anonymous communications and/or messages are not accepted by the system.",
                "url": "https://capec.mitre.org/data/definitions/22.html"
              }
            },
            {
              "id": "CAPEC-209",
              "parameters": {
                "title": "XSS Using MIME Type Mismatch",
                "attack_methods": "",
                "mitigations": "",
                "url": "https://capec.mitre.org/data/definitions/209.html"
              }
            },
            {
              "id": "CAPEC-182",
              "parameters": {
                "title": "Flash Injection",
                "attack_methods": "",
                "mitigations": "Implementation: use crossdomain.xml file to allow the application domain to load stuff or the SWF file called by other domain.|Implementation: use SSL when loading external data|Implementation: remove debug information.|Implementation: use validation on both client and server side.|Implementation: remove sensitive information such as user name and password in the SWF file.",
                "url": "https://capec.mitre.org/data/definitions/182.html"
              }
            },
            {
              "id": "CAPEC-153",
              "parameters": {
                "title": "Input Data Manipulation",
                "attack_methods": "",
                "mitigations": "",
                "url": "https://capec.mitre.org/data/definitions/153.html"
              }
            },
            {
              "id": "CAPEC-14",
              "parameters": {
                "title": "Client-side Injection-induced Buffer Overflow",
                "attack_methods": "",
                "mitigations": "Use OS-level preventative functionality. Not a complete solution.|Ensure all buffer uses are consistently bounds-checked.|Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.|Use an abstraction library to abstract away risky APIs. Not a complete solution.|Use a language or compiler that performs automatic bounds checking.|Perform input validation for length of buffer inputs.|The client software should have the latest patches and should be audited for vulnerabilities before being used to communicate with potentially hostile servers.|The client software should not install untrusted code from a non-authenticated server.",
                "url": "https://capec.mitre.org/data/definitions/14.html"
              }
            },
            {
              "id": "CAPEC-136",
              "parameters": {
                "title": "LDAP Injection",
                "attack_methods": "",
                "mitigations": "Use of custom error pages - Attackers can glean information about the nature of queries from descriptive error messages. Input validation must be coupled with customized error pages that inform about an error without disclosing information about the LDAP or application.|Strong input validation - All user-controllable input must be validated and filtered for illegal characters as well as LDAP content.",
                "url": "https://capec.mitre.org/data/definitions/136.html"
              }
            },
            {
              "id": "CAPEC-135",
              "parameters": {
                "title": "Format String Injection",
                "attack_methods": "",
                "mitigations": "Strong input validation - All user-controllable input must be validated and filtered for illegal formatting characters.|Limit the usage of formatting string functions.",
                "url": "https://capec.mitre.org/data/definitions/135.html"
              }
            },
            {
              "id": "CAPEC-13",
              "parameters": {
                "title": "Subverting Environment Variable Values",
                "attack_methods": "",
                "mitigations": "Apply the least privilege principles. If a process has no legitimate reason to read an environment variable do not give that privilege.|Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system.|Protect the configuration files which contain environment variables against illegitimate read and write access.|Protect environment variables against unauthorized read and write access.",
                "url": "https://capec.mitre.org/data/definitions/13.html"
              }
            },
            {
              "id": "CAPEC-120",
              "parameters": {
                "title": "Double Encoding",
                "attack_methods": "",
                "mitigations": "There are tools to scan HTTP requests to the server for valid URL such as URLScan from Microsoft (http://www.microsoft.com/technet/security/tools/urlscan.mspx).|Regular expression can be used to match safe URL patterns. However, that may discard valid URL requests if the regular expression is too restrictive.|Refer to the RFCs to safely decode URL.|Any security checks should occur after the data has been decoded and validated as correct data format. Do not repeat decoding process, if bad character are left after decoding process, treat the data as suspicious, and fail the validation process.|When client input is required from web-based forms, avoid using the \"GET\" method to submit data, as the method causes the form data to be appended to the URL and is easily manipulated. Instead, use the \"POST method whenever possible.|Be aware of the threat of alternative method of data encoding and obfuscation technique such as IP address encoding.|Assume all input is malicious. Create an allowlist that defines all valid input to the software system based on the requirements specifications. Input that does not match against the allowlist should not be permitted to enter into the system. Test your decoding process against malicious input.",
                "url": "https://capec.mitre.org/data/definitions/120.html"
              }
            },
            {
              "id": "CAPEC-110",
              "parameters": {
                "title": "SQL Injection through SOAP Parameter Tampering",
                "attack_methods": "",
                "mitigations": "At the database level, ensure that the database user used by the application in a particular context has the minimum needed privileges to the database that are needed to perform the operation. When possible, run queries against pre-generated views rather than the tables directly.|Ensure that prepared statements or other mechanism that enables parameter binding is used when accessing the database in a way that would prevent the attackers' supplied data from controlling the structure of the executed query.|Properly validate and sanitize/reject user input at the service provider.",
                "url": "https://capec.mitre.org/data/definitions/110.html"
              }
            },
            {
              "id": "CAPEC-109",
              "parameters": {
                "title": "Object Relational Mapping Injection",
                "attack_methods": "",
                "mitigations": "Ensure to keep up to date with security relevant updates to the persistence framework used within your application.|Remember to understand how to use the data access methods generated by the ORM tool / framework properly in a way that would leverage the built-in security mechanisms of the framework",
                "url": "https://capec.mitre.org/data/definitions/109.html"
              }
            },
            {
              "id": "CAPEC-108",
              "parameters": {
                "title": "Command Line Execution through SQL Injection",
                "attack_methods": "",
                "mitigations": "Do not implicitly trust the data stored in the database. Re-validate it prior to usage to make sure that it is safe to use in a given context (e.g. as a command line argument).|Properly validate the data (syntactically and semantically) before writing it to the database.|Disable MSSQL xp_cmdshell directive on the database",
                "url": "https://capec.mitre.org/data/definitions/108.html"
              }
            },
            {
              "id": "CAPEC-104",
              "parameters": {
                "title": "Cross Zone Scripting",
                "attack_methods": "",
                "mitigations": "Ensure proper HTML output encoding before writing user supplied data to the page|Limit the sites that are being added to the local machine zone and restrict the privileges of the code running in that zone to the bare minimum|Limit the flow of untrusted data into the privileged areas of the system that run in the higher trust zone|Ensure that sufficient input validation is performed for any potentially untrusted data before it is used in any privileged context or zone|Disable script execution.",
                "url": "https://capec.mitre.org/data/definitions/104.html"
              }
            },
            {
              "id": "CAPEC-101",
              "parameters": {
                "title": "Server Side Include (SSI) Injection",
                "attack_methods": "",
                "mitigations": "Server Side Includes must be enabled only if there is a strong business reason to do so. Every additional component enabled on the web server increases the attack surface as well as administrative overhead|All user controllable input must be appropriately sanitized before use in the application. This includes omitting, or encoding, certain characters or strings that have the potential of being interpreted as part of an SSI directive|Set the OPTIONS IncludesNOEXEC in the global access.conf file or local .htaccess (Apache) file to deny SSI execution in directories that do not need them",
                "url": "https://capec.mitre.org/data/definitions/101.html"
              }
            },
            {
              "id": "CAPEC-10",
              "parameters": {
                "title": "Buffer Overflow via Environment Variables",
                "attack_methods": "",
                "mitigations": "There are tools such as Sharefuzz [REF-2] which is an environment variable fuzzer for Unix that support loading a shared library. You can use Sharefuzz to determine if you are exposing an environment variable vulnerable to buffer overflow.|Use a language or compiler that performs automatic bounds checking|Do not use untrusted data in your environment variables.|Do not expose environment variable to the user.",
                "url": "https://capec.mitre.org/data/definitions/10.html"
              }
            }
          ],
          "ranking": {
            "categorization": [
              {
                "id": "CWE-1003",
                "parameters": {
                  "title": "Weaknesses for Simplified Mapping of Published Vulnerabilities",
                  "url": "https://cwe.mitre.org/data/definitions/1003.html"
                }
              },
              {
                "id": "CWE-1005",
                "parameters": {
                  "title": "7PK - Input Validation and Representation",
                  "url": "https://cwe.mitre.org/data/definitions/1005.html"
                }
              },
              {
                "id": "CWE-1019",
                "parameters": {
                  "title": "Validate Inputs",
                  "url": "https://cwe.mitre.org/data/definitions/1019.html"
                }
              },
              {
                "id": "CWE-1163",
                "parameters": {
                  "title": "SEI CERT C Coding Standard - Guidelines 09. Input Output (FIO)",
                  "url": "https://cwe.mitre.org/data/definitions/1163.html"
                }
              },
              {
                "id": "CWE-1200",
                "parameters": {
                  "title": "Weaknesses in the 2019 CWE Top 25 Most Dangerous Software Errors",
                  "url": "https://cwe.mitre.org/data/definitions/1200.html"
                }
              },
              {
                "id": "CWE-1350",
                "parameters": {
                  "title": "Weaknesses in the 2020 CWE Top 25 Most Dangerous Software Weaknesses",
                  "url": "https://cwe.mitre.org/data/definitions/1350.html"
                }
              },
              {
                "id": "CWE-635",
                "parameters": {
                  "title": "Weaknesses Originally Used by NVD from 2008 to 2016",
                  "url": "https://cwe.mitre.org/data/definitions/635.html"
                }
              },
              {
                "id": "CWE-722",
                "parameters": {
                  "title": "OWASP Top Ten 2004 Category A1 - Unvalidated Input",
                  "url": "https://cwe.mitre.org/data/definitions/722.html"
                }
              },
              {
                "id": "CWE-738",
                "parameters": {
                  "title": "CERT C Secure Coding Standard (2008) Chapter 5 - Integers (INT)",
                  "url": "https://cwe.mitre.org/data/definitions/738.html"
                }
              },
              {
                "id": "CWE-742",
                "parameters": {
                  "title": "CERT C Secure Coding Standard (2008) Chapter 9 - Memory Management (MEM)",
                  "url": "https://cwe.mitre.org/data/definitions/742.html"
                }
              },
              {
                "id": "CWE-746",
                "parameters": {
                  "title": "CERT C Secure Coding Standard (2008) Chapter 13 - Error Handling (ERR)",
                  "url": "https://cwe.mitre.org/data/definitions/746.html"
                }
              },
              {
                "id": "CWE-747",
                "parameters": {
                  "title": "CERT C Secure Coding Standard (2008) Chapter 14 - Miscellaneous (MSC)",
                  "url": "https://cwe.mitre.org/data/definitions/747.html"
                }
              },
              {
                "id": "CWE-751",
                "parameters": {
                  "title": "2009 Top 25 - Insecure Interaction Between Components",
                  "url": "https://cwe.mitre.org/data/definitions/751.html"
                }
              },
              {
                "id": "CWE-872",
                "parameters": {
                  "title": "CERT C++ Secure Coding Section 04 - Integers (INT)",
                  "url": "https://cwe.mitre.org/data/definitions/872.html"
                }
              },
              {
                "id": "CWE-876",
                "parameters": {
                  "title": "CERT C++ Secure Coding Section 08 - Memory Management (MEM)",
                  "url": "https://cwe.mitre.org/data/definitions/876.html"
                }
              },
              {
                "id": "CWE-883",
                "parameters": {
                  "title": "CERT C++ Secure Coding Section 49 - Miscellaneous (MSC)",
                  "url": "https://cwe.mitre.org/data/definitions/883.html"
                }
              },
              {
                "id": "CWE-994",
                "parameters": {
                  "title": "SFP Secondary Cluster: Tainted Input to Variable",
                  "url": "https://cwe.mitre.org/data/definitions/994.html"
                }
              }
            ],
            "wasc": [
              {
                "id": "WASC-20",
                "parameters": {
                  "title": "Improper Input Handling",
                  "url": "http://projects.webappsec.org/Improper-Input-Handling"
                }
              }
            ],
            "att&ck_mitre": [
              {
                "id": "T1574.007",
                "parameters": {
                  "profile": "mitre-attack",
                  "name": "Path Interception by PATH Environment Variable",
                  "description": "Adversaries may execute their own malicious payloads by hijacking environment variables used to load libraries. Adversaries may place a program in an earlier entry in the list of directories stored in the PATH environment variable, which Windows will then execute when it searches sequentially through that PATH listing in search of the binary that was called from a script or the command line.\n\nThe PATH environment variable contains a list of directories. Certain methods of executing a program (namely using cmd.exe or the command-line) rely solely on the PATH environment variable to determine the locations that are searched for a program when the path for the program is not given. If any directories are listed in the PATH environment variable before the Windows directory, <code>%SystemRoot%\\system32</code> (e.g., <code>C:\\Windows\\system32</code>), a program may be placed in the preceding directory that is named the same as a Windows program (such as cmd, PowerShell, or Python), which will be executed when that command is executed from a script or command-line.\n\nFor example, if <code>C:\\example path</code> precedes </code>C:\\Windows\\system32</code> is in the PATH environment variable, a program that is named net.exe and placed in <code>C:\\example path</code> will be called instead of the Windows system \"net\" when \"net\" is executed from the command-line.",
                  "tactic": "defense-evasion,privilege-escalation,persistence",
                  "permission_required": "",
                  "bypassed_defenses": "Application control",
                  "data_sources": "File monitoring,Process monitoring",
                  "url": "https://attack.mitre.org/techniques/T1574/007",
                  "file": "https://raw.githubusercontent.com/mitre/cti/master/enterprise-attack/attack-pattern/attack-pattern--0c2d00da-7742-49e7-9928-4514e5075d32.json"
                }
              },
              {
                "id": "T1574.006",
                "parameters": {
                  "profile": "mitre-attack",
                  "name": "LD_PRELOAD",
                  "description": "Adversaries may execute their own malicious payloads by hijacking the dynamic linker used to load libraries. The dynamic linker is used to load shared library dependencies needed by an executing program. The dynamic linker will typically check provided absolute paths and common directories for these dependencies, but can be overridden by shared objects specified by LD_PRELOAD to be loaded before all others.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)\n\nAdversaries may set LD_PRELOAD to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. LD_PRELOAD can be set via the environment variable or <code>/etc/ld.so.preload</code> file.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries) Libraries specified by LD_PRELOAD with be loaded and mapped into memory by <code>dlopen()</code> and <code>mmap()</code> respectively.(Citation: Code Injection on Linux and macOS) (Citation: Uninformed Needle) (Citation: Phrack halfdead 1997)\n\nLD_PRELOAD hijacking may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. Execution via LD_PRELOAD hijacking may also evade detection from security products since the execution is masked under a legitimate process.",
                  "tactic": "defense-evasion,privilege-escalation,persistence",
                  "permission_required": "",
                  "bypassed_defenses": "",
                  "data_sources": "Environment variable,File monitoring,Process monitoring",
                  "url": "https://attack.mitre.org/techniques/T1574/006",
                  "file": "https://raw.githubusercontent.com/mitre/cti/master/enterprise-attack/attack-pattern/attack-pattern--633a100c-b2c9-41bf-9be5-905c1b16c825.json"
                }
              },
              {
                "id": "T1562.003",
                "parameters": {
                  "profile": "mitre-attack",
                  "name": "Impair Command History Logging",
                  "description": "Adversaries may impair command history logging to hide commands they run on a compromised system. Various command interpreters keep track of the commands users type in their terminal so that users can retrace what they've done. \n\nOn Linux and macOS, command history is tracked in a file pointed to by the environment variable <code>HISTFILE</code>. When a user logs off a system, this information is flushed to a file in the user's home directory called <code>~/.bash_history</code>. The <code>HISTCONTROL</code> environment variable keeps track of what should be saved by the <code>history</code> command and eventually into the <code>~/.bash_history</code> file when a user logs out. <code>HISTCONTROL</code> does not exist by default on macOS, but can be set by the user and will be respected.\n\nAdversaries may clear the history environment variable (<code>unset HISTFILE</code>) or set the command history size to zero (<code>export HISTFILESIZE=0</code>) to prevent logging of commands. Additionally, <code>HISTCONTROL</code> can be configured to ignore commands that start with a space by simply setting it to \"ignorespace\". <code>HISTCONTROL</code> can also be set to ignore duplicate commands by setting it to \"ignoredups\". In some Linux systems, this is set by default to \"ignoreboth\" which covers both of the previous examples. This means that  ls will not be saved, but ls would be saved by history. Adversaries can abuse this to operate without leaving traces by simply prepending a space to all of their terminal commands.\n\nOn Windows systems, the <code>PSReadLine</code> module tracks commands used in all PowerShell sessions and writes them to a file (<code>$env:APPDATA\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt</code> by default). Adversaries may change where these logs are saved using <code>Set-PSReadLineOption -HistorySavePath {File Path}</code>. This will cause <code>ConsoleHost_history.txt</code> to stop receiving logs. Additionally, it is possible to turn off logging to this file using the PowerShell command <code>Set-PSReadlineOption -HistorySaveStyle SaveNothing</code>.(Citation: Microsoft PowerShell Command History)(Citation: Sophos PowerShell command audit)(Citation: Sophos PowerShell Command History Forensics)",
                  "tactic": "defense-evasion",
                  "permission_required": "User",
                  "bypassed_defenses": "Log analysis,Host forensic analysis",
                  "data_sources": "Process monitoring,Authentication logs,File monitoring,Environment variable,Process command-line parameters,PowerShell logs",
                  "url": "https://attack.mitre.org/techniques/T1562/003",
                  "file": "https://raw.githubusercontent.com/mitre/cti/master/enterprise-attack/attack-pattern/attack-pattern--8f504411-cb96-4dac-a537-8d2bb7679c59.json"
                }
              }
            ]
          }
        }
      }
    ]
  },
  "risk": {
    "cvss": {
      "cvss2": {
        "vector": "AV:N/AC:L/Au:N/C:P/I:P/A:P",
        "base_score": "7.5",
        "impact_score": "6.4",
        "exploit_score": "10.0",
        "access_vector": "NETWORK",
        "access_complexity": "LOW",
        "authentication": "NONE",
        "confidentiality_impact": "PARTIAL",
        "integrity_impact": "PARTIAL",
        "availability_impact": "PARTIAL"
      },
      "cvss3": {
        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "base_score": "9.8",
        "impact_score": "5.9",
        "exploit_score": "3.9",
        "attack_vector": "NETWORK",
        "attack_complexity": "LOW",
        "privileges_required": "NONE",
        "user_interaction": "NONE",
        "score": "UNCHANGED",
        "confidentiality_impact": "HIGH",
        "integrity_impact": "HIGH",
        "availability_impact": "HIGH"
      }
    }
  },
  "inspection": {
    "remote": [
      {
        "nessus": [
          {
            "id": "122859",
            "parameters": {
              "family": "Windows : Microsoft Bulletins",
              "name": "Security Updates for Microsoft Sharepoint Server (March 2019)",
              "file": "smb_nt_ms19_mar_office_sharepoint.nasl",
              "url": "https://www.tenable.com/plugins/index.php?view=single&id=122859"
            }
          },
          {
            "id": "122155",
            "parameters": {
              "family": "Windows : Microsoft Bulletins",
              "name": "Security Updates for Microsoft Sharepoint Server (February 2019)",
              "file": "smb_nt_ms19_feb_office_sharepoint.nasl",
              "url": "https://www.tenable.com/plugins/index.php?view=single&id=122155"
            }
          }
        ]
      }
    ],
    "local": []
  },
  "exploitation": [
    {
      "github": [
        {
          "id": "177246255",
          "parameters": {
            "title": "CVE-2019-0604",
            "file": "https://github.com/linhlhq/CVE-2019-0604",
            "url": "https://github.com/linhlhq/CVE-2019-0604"
          }
        },
        {
          "id": "179413290",
          "parameters": {
            "title": "likescam/CVE-2019-0604_sharepoint_CVE",
            "file": "https://github.com/likescam/CVE-2019-0604_sharepoint_CVE",
            "url": "https://github.com/likescam/CVE-2019-0604_sharepoint_CVE"
          }
        },
        {
          "id": "193926769",
          "parameters": {
            "title": "cve-2019-0604 SharePoint RCE exploit",
            "file": "https://github.com/k8gege/CVE-2019-0604",
            "url": "https://github.com/k8gege/CVE-2019-0604"
          }
        },
        {
          "id": "208650796",
          "parameters": {
            "title": "CVE-2019-0604: SharePoint RCE detection rules and sample PCAP",
            "file": "https://github.com/m5050/CVE-2019-0604",
            "url": "https://github.com/m5050/CVE-2019-0604"
          }
        },
        {
          "id": "227013447",
          "parameters": {
            "title": "k8gegeSharePoint RCE exploit cve-2019-0604-exp.pypayload",
            "file": "https://github.com/boxhg/CVE-2019-0604",
            "url": "https://github.com/boxhg/CVE-2019-0604"
          }
        }
      ]
    },
    {
      "saint": [
        {
          "id": "win_patch_sharepoint_sharepointver",
          "parameters": {
            "title": "Microsoft SharePoint Picker.aspx deserialization vulnerability",
            "file": "sharepoint_picker_deserial",
            "url": "https://download.saintcorporation.com/cgi-bin/exploit_info/sharepoint_picker_deserial"
          }
        }
      ]
    }
  ],
  "defense": {
    "preventive": [
      {
        "bid": [
          {
            "id": "106914",
            "parameters": {
              "class": "bulletin",
              "url": "http://www.securityfocus.com/bid/106914"
            }
          }
        ]
      },
      {
        "microsoft": [
          {
            "id": "4461630",
            "parameters": {
              "class": "fix",
              "url": "https://support.microsoft.com/help/4461630"
            }
          },
          {
            "id": "4462143",
            "parameters": {
              "class": "fix",
              "url": "https://support.microsoft.com/help/4462143"
            }
          },
          {
            "id": "4462155",
            "parameters": {
              "class": "fix",
              "url": "https://support.microsoft.com/help/4462155"
            }
          },
          {
            "id": "4462171",
            "parameters": {
              "class": "fix",
              "url": "https://support.microsoft.com/help/4462171"
            }
          },
          {
            "id": "CVE-2019-0604",
            "parameters": {
              "class": "bulletin",
              "url": "https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0604"
            }
          }
        ]
      },
      {
        "zdi": [
          {
            "id": "ZDI-19-181",
            "parameters": {
              "class": "bulletin",
              "url": "https://www.zerodayinitiative.com/advisories/ZDI-19-181/"
            }
          }
        ]
      }
    ],
    "detective": [
      {
        "juniper": [
          {
            "id": "HTTP:EXPLOIT:CVE-2019-0604-RCE1",
            "parameters": {
              "class": "HTTP",
              "title": "This signature detects attempts to exploit a known vulnerability against Microsoft Share Point. A successful attack can lead to arbitrary code execution.",
              "url": "https://threatlabs.juniper.net/home/search/#/details/?sigtype=ips&sigid=HTTP:EXPLOIT:CVE-2019-0604-RCE1"
            }
          },
          {
            "id": "HTTP:EXPLOIT:CVE-2019-0604-RCE2",
            "parameters": {
              "class": "HTTP",
              "title": "This signature detects attempts to exploit a known vulnerability against Microsoft Share Point. A successful attack can lead to arbitrary code execution.",
              "url": "https://threatlabs.juniper.net/home/search/#/details/?sigtype=ips&sigid=HTTP:EXPLOIT:CVE-2019-0604-RCE2"
            }
          }
        ]
      },
      {
        "snort": [
          {
            "id": "51368",
            "parameters": {
              "class": "trojan-activity",
              "title": "MALWARE-BACKDOOR Win.Backdoor.Agent webshell inbound request attempt",
              "url": "https://snort.org/rule_docs/1-51368/"
            }
          },
          {
            "id": "50277",
            "parameters": {
              "class": "trojan-activity",
              "title": "MALWARE-BACKDOOR Win.Backdoor.Chopper webshell inbound request attempt",
              "url": "https://snort.org/rule_docs/1-50277/"
            }
          },
          {
            "id": "50276",
            "parameters": {
              "class": "trojan-activity",
              "title": "MALWARE-BACKDOOR Win.Backdoor.Chopper webshell inbound request attempt",
              "url": "https://snort.org/rule_docs/1-50276/"
            }
          },
          {
            "id": "55862",
            "parameters": {
              "class": "attempted-user",
              "title": "SERVER-WEBAPP Microsoft SharePoint EntityInstanceIdEncoder remote code execution attempt",
              "url": "https://snort.org/rule_docs/1-55862/"
            }
          },
          {
            "id": "50275",
            "parameters": {
              "class": "attempted-user",
              "title": "SERVER-WEBAPP Microsoft SharePoint EntityInstanceIdEncoder remote code execution attempt",
              "url": "https://snort.org/rule_docs/1-50275/"
            }
          },
          {
            "id": "49861",
            "parameters": {
              "class": "attempted-user",
              "title": "SERVER-WEBAPP Microsoft SharePoint EntityInstanceIdEncoder remote code execution attempt",
              "url": "https://snort.org/rule_docs/1-49861/"
            }
          }
        ]
      },
      {
        "suricata": [
          {
            "id": "2027345",
            "parameters": {
              "class": "attempted-admin",
              "title": "ET WEB_SPECIFIC_APPS Possible SharePoint RCE Attempt (CVE-2019-0604)",
              "url": "http://doc.emergingthreats.net/2027345/"
            }
          }
        ]
      }
    ]
  }
}